def solution(g):
    s,e,dic,a = 0,0,{},[]
    m,d = len(set(g)),len(g)+1
    
    while e <= len(g):        
        while len(dic) < m:
            if g[e] not in dic.keys():
                dic[g[e]] = 1
                e += 1
            else:
                dic[g[e]] += 1    
                e += 1
        if 0 not in dic.values():
            while 0 not in dic.values():
                dic[g[s]] -= 1
                s += 1
            if e-s+1 < d:
                a = [s,e]
                d = e-s+1
        if e <= len(g):
            if e == len(g):
                break            
            dic[g[e]] += 1
            e += 1
            dic[g[s]] -= 1
            s += 1
    return a

    # 투 포인터와 슬라이딩 윈도우 개념 차이 잘 숙지할 것!!!!
    # 위 문제는 투포인터로 풀수도 있고 슬라이딩 윈도우로 풀수도 있지만, 효율성에서 만점을 받으려면 슬라이딩 윈도우로 풀어내야한다!!!
    # 투포인트로 짰다가 자꾸 효율성 틀려서 슬라이딩 윈도우로 조금 바꿔주니 바로 효율성 두개 통과;;;;;
    # 슬라이딩 윈도우 최소 조건을 만족하는 두 포인터 위치를 잡은뒤 유리창을 닦듯이 밀어주며 더 포인터 간격을 최소화 할 수 있는지 확인.
    # 투포인터는  포인터간 최소 조건이 뒷 포인트가 이동할때마다 갱신되어 비효율성 증가. (ex) 6개가 최솟값으로 발견됬다면 이후 탐색하는 곳에서는 6개씩만 보면된다. 
    # but naive한 투포인터는 최솟값이 발견되어도 그 이후 값을 check할때 7개 이상인 배열에 대해서도 가능한지 check하여 효율성이 떨어지게 된다.)

    # 문제 풀기전 구상해본 알고리즘 순서도
    # 1. 리스트의 마지막 값의 인덱스와 e가 일치할때까지 아래 과정을 반복수행
    # 2. 최초의 모든 보석을 포함하는 end point Index를 가리킬때까지 e의 값을 올려주며 map에 보석갯수를 저장.
    # 3. 이후 s 값을 하나씩 올려주며 최초로 모든보석을 포함하는 구성이 깨질때까지 (map에 존재하는 어떤 한 종류의 보석이 0개로 됨) s의 값을 끌어 올려준다.
    # 4. 해당 최소길이를 이후 더 작은 길이의 리스트가 등장하면 비교할 수 있도록 저장해주고, 해당 보석의 진열장 좌표를 저장한다.
    # 5. 만일 현재 e가 end point를 가리킨다면 루프를 탈출한다.
    # 6. 그렇지 않다면 e와 s를 한칸씩 끌어 올려주고 각각의 보석을 더해주고 빼준다(슬라이딩 윈도우), 다시 3번부터 수행한다.
