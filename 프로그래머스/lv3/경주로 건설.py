def solution(b):
    d = {(0,0) : 0} # 초기 위치 가격
    s = [[0,0]] # 초기 위치
    return move(s,d,b)

def move(j,d,k):
    t,a,c = [],[],0 
    for n in j:
        if (n[-2],n[-1]) == (len(k)-1,len(k)-1): # 목표점에 도달한경우 해당 트랙 삭제
            continue
        for x,y in [(n[-2]+1,n[-1]),(n[-2],n[-1]+1),(n[-2]-1,n[-1]),(n[-2],n[-1]-1)]: # 상하좌우 이동
            c += 1
            if (len(k)>x>=0) and (len(k)>y>=0) and (k[x][y]) != 1: # 벽이 있거나 지도 밖으로 이동하는것 방지
                if len(n) == 2:   # 첫 이동일경우 두시점 전이 존재 하지 않으므로 바로 이동
                    t.append(n+[x,y])
                    d[(n[-2],n[-1],x,y)] = 1 # 딕셔너리에 이전좌표와 현재좌표를 같이 넣어줌 why? 이전 좌표가 어디였나에 따라 다음좌표이동때 비용이 코너일수도 직선일수도 있다.
                else:
                    if (n[-2],n[-1],x,y) not in d: # 딕셔너리에 해당 이동 기록 좌표에 대한 비용이 없을 경우 비용 입력
                        if abs(x-n[-4]) == 1:  # 코너 이동의 경우 x나 y 이동거리 절댓값이 1인점을 이용, 코너와 직선의 경우를 분리
                            d[(n[-2],n[-1],x,y)] = d[(n[-4],n[-3],n[-2],n[-1])] + 6 
                        else: 
                            d[(n[-2],n[-1],x,y)] = d[(n[-4],n[-3],n[-2],n[-1])] + 1
                        t.append(n+[x,y])
                    else:   # 딕셔너리에 해당 이동 기록 좌표에 대한 비용이 있을 경우 현재 경로가 더 적은 비용이 들었다면 비용 값 갱신
                        if abs(x-n[-4]) == 1:
                            if d[(n[-2],n[-1],x,y)] >= d[(n[-4],n[-3],n[-2],n[-1])] + 6 :
                                d[(n[-2],n[-1],x,y)] = d[(n[-4],n[-3],n[-2],n[-1])] + 6
                                t.append(n+[x,y])
                        else:
                            if  d[(n[-2],n[-1],x,y)] > d[(n[-4],n[-3],n[-2],n[-1])] +1:
                                d[(n[-2],n[-1],x,y)] = d[(n[-4],n[-3],n[-2],n[-1])] + 1
                                t.append(n+[x,y])
    if c == 0 :
        for i in d.keys():
            if i[-1]+i[-2] == (len(k)-1)*2:
                a.append(d[i])
        return min(a)*100 # 경로에 도달한 값들중 최소비용 리턴
    return move(t,d,k)  # 재귀를 통해 끝경로 까지 이동 후

### 문제 핵심 check point###
# 똑같이 1,1 에서 1,2로 가는 경우일 지라도, 1,1에서 오기전에 0,1에서 왔는지 1,0에서 왔는지에 대한 정보가 비용에 영향을 미치므로 딕셔너리에도 두 시점 이전 정보까지 index로 저장해줄것
# 추후 다시 볼 때 해야할일 collection deque, queue Queue 써서 코드 줄여보기