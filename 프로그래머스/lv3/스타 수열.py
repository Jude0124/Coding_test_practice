from collections import defaultdict

def solution(a):
    dic,k = defaultdict(list),0
    
    for i in range(len(a)):
        dic[a[i]].append(i)
        
    for i in list(dic.values()):        
        cnt,c = 0,-1  # cnt == 스타수열 조건을 만족하는 스타수열 쌍의 갯수/ c == 가장 직전에 스타수열을 조건을 만족한 한쌍(인접한 두index)의 뒷 index.
        for j in i:
            if j == 0: # 1-2. 들어온 index j가 0일 경우 맨 앞 값이므로 뒷좌표와 스타수열 한쌍을 이룸. (0,1) -> c == 1 cnt +=1
                c = j+1
                cnt += 1
            elif c == j-1: #2-1. 선입선출에 따라 앞좌표와 스타수열 한쌍을 이뤄야하지만, 앞좌표가 동일 값일 경우 뒷좌표와 한쌍을 이룸.
                cnt +=1
                c = j+1
            elif c == j: # 2-2. 들어온 index j 가 직전의 스타수열 한쌍의 뒷좌표일 경우, 이는 중복([1,1])을 의미하므로 c를 한칸 뒤로 밀어줌. 
                c = j+1
            else:       # 1-1. 들어온 index j가 0이 아닐 경우 앞좌표와 스타수열 한쌍을 이룸. c == j cnt += 1
                cnt += 1
                c = j
        if c == len(a): #3.선입선출조건을 만족하지못해 마지막까지 밀린 경우가 존재할 경우, 해당 좌표는 쌍을 이룰 수 없으므로 스타수열갯수 하나 제거 
            cnt -= 1    #  ex) [2,1,2,1,1] -> (2,1),(2,1) (1,)
        k = max(k,cnt)
        
    return k*2

# 알고리즘 순서 // 최대 리스트의 길이는 500,000 이라하였으므로 시간복잡도를 최악의 경우로 가정하고 알고리즘을 구상.
# 1). 등장하는 숫자들을 key로, 숫자들의 index(등장한 위치좌표)들을 values(list)로 하여 딕셔너리를 짠다. ex) [1,1,3,2,1,3] -> {1:[0,1,4],3:[2,5],2:[3]}
#    시간복잡도 -> O(N)
# 2). list(dic.values()) 에 대하여 loop를 돌며 각각의 값들이 스타수열로 가질 수 있는 최대 길이를 계산해준다. 
#    시간복잡도는 O(N) why? 딕셔너리 values의 총 갯수가 초기 길이와 동일하기 때문!!
# 3). 각각의 key들에 대하여 루프가 끝날 때마다 기존의 최댓값(k) 와 비교하며 최댓값을 갱신해준 후 최댓값을 출력해준다.